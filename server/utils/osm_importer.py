import os
import requests
import logging
import psycopg2
from psycopg2.extras import execute_values
from dotenv import load_dotenv
import uuid

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Load environment variables (if running standalone)
load_dotenv()

OVERPASS_URL = "https://overpass-api.de/api/interpreter"

def get_db_connection():
    """Establish a database connection."""
    try:
        conn = psycopg2.connect(
            dbname=os.getenv("DB_NAME") or os.getenv("SUPABASE_DB_NAME"),
            user=os.getenv("DB_USER") or os.getenv("SUPABASE_DB_USER"),
            password=os.getenv("DB_PASSWORD") or os.getenv("SUPABASE_DB_PASSWORD"),
            host=os.getenv("DB_HOST") or os.getenv("SUPABASE_DB_HOST"),
            port=os.getenv("DB_PORT") or os.getenv("SUPABASE_DB_PORT")
        )
        return conn
    except Exception as e:
        logger.error(f"Failed to connect to database: {e}")
        raise

def fetch_osm_data(lat: float = None, lng: float = None, radius_meters: int = 50000, region: str = None):
    """
    Fetch golf courses from OSM within a radius OR a specific region.
    """
    if region:
        # Query by Area/Region Name
        # We try to match a named area (e.g., "Michigan", "Detroit")
        # Trying a more flexible search - first try exact name, if that fails, maybe we need to be smarter.
        # But for now, let's just use the name directly.
        
        overpass_query = f"""
        [out:json][timeout:300];
        area["name"="{region}"]->.searchArea;
        (
          way["leisure"="golf_course"](area.searchArea);
          relation["leisure"="golf_course"](area.searchArea);
        );
        out center tags;
        """
        logger.info(f"Querying OSM for region: {region}")
    
    elif lat is not None and lng is not None:
        # Query by Radius
        overpass_query = f"""
        [out:json][timeout:25];
        (
          way["leisure"="golf_course"](around:{radius_meters},{lat},{lng});
          relation["leisure"="golf_course"](around:{radius_meters},{lat},{lng});
        );
        out center tags;
        """
        logger.info(f"Querying OSM for radius around {lat}, {lng}")
    
    else:
        logger.error("Neither region nor coordinates provided")
        return None
    
    try:
        response = requests.get(OVERPASS_URL, params={'data': overpass_query})
        response.raise_for_status()
        return response.json()
    except Exception as e:
        logger.error(f"Failed to fetch data from Overpass API: {e}")
        return None

def parse_osm_element(element):
    """
    Parse a single OSM element into our database schema format.
    """
    tags = element.get('tags', {})
    
    # Extract coordinates (use center if available)
    lat = element.get('lat')
    lon = element.get('lon')
    if not lat or not lon:
        center = element.get('center', {})
        lat = center.get('lat')
        lon = center.get('lon')
    
    if not lat or not lon:
        return None

    # Map fields
    name = tags.get('name', 'Unknown Golf Course')
    
    # Address mapping
    street = tags.get('addr:street', '')
    number = tags.get('addr:housenumber', '')
    address = f"{number} {street}".strip() if street else None
    
    city = tags.get('addr:city')
    state = tags.get('addr:state')
    zip_code = tags.get('addr:postcode')
    
    # Golf specific details
    holes = tags.get('golf:holes')
    try:
        num_holes = int(holes) if holes and holes.isdigit() else 18 # Default to 18 if unknown
    except:
        num_holes = 18

    phone = tags.get('phone') or tags.get('contact:phone')
    website = tags.get('website') or tags.get('contact:website')
    
    # Return dictionary matching our schema (subset)
    # Note: Global ID will be generated by DB or we could use OSM ID?
    # For now, let DB generate UUID, we'll store OSM ID in notes or check existing by name/location
    return {
        'club_name': name,
        'address': address,
        'city': city,
        'state': state,
        'zip_code': zip_code,
        'number_of_holes': num_holes,
        'lat': lat,
        'lng': lon,
        'website': website,
        'phone': phone,
        'driving_range': tags.get('driving_range') == 'yes',
        # Default other fields to None or False
    }

def import_courses_for_location(lat: float = None, lng: float = None, radius_miles: int = 25, region: str = None):
    """
    Main function to import courses.
    """
    if region:
        logger.info(f"Fetching OSM data for Region: {region}")
        data = fetch_osm_data(region=region)
    elif lat is not None and lng is not None:
        radius_meters = int(radius_miles * 1609.34)
        logger.info(f"Fetching OSM data for lat={lat}, lng={lng}, radius={radius_miles}mi")
        data = fetch_osm_data(lat=lat, lng=lng, radius_meters=radius_meters)
    else:
        logger.error("Missing location arguments")
        return 0

    if not data or 'elements' not in data:
        logger.warning("No data returned from OSM")
        return 0

    elements = data['elements']
    logger.info(f"Found {len(elements)} elements")
    
    parsed_courses = []
    for el in elements:
        parsed = parse_osm_element(el)
        if parsed:
            parsed_courses.append(parsed)

    if not parsed_courses:
        logger.info("No valid courses to insert")
        return 0

    # Insert into Database
    count = 0
    conn = get_db_connection()
    try:
        with conn.cursor() as cursor:
            # We'll stick to a simple INSERT for now. 
            # ideally updates should check for nearby matches to avoid duplicates
            
            # Simple deduplication check by name within very short distance could be better, 
            # but for this MVP script, we'll trust the caller or DB constraints.
            # Assuming 'geom' is GEOMETRY type
            
            insert_query = """
            INSERT INTO golfclub (
                global_id,
                club_name, address, city, state, zip_code, 
                number_of_holes, website, phone,
                driving_range, geom, 
                price_tier, difficulty 
            ) VALUES (
                %(global_id)s,
                %(club_name)s, %(address)s, %(city)s, %(state)s, %(zip_code)s,
                %(number_of_holes)s, %(website)s, %(phone)s,
                %(driving_range)s, ST_SetSRID(ST_MakePoint(%(lng)s, %(lat)s), 4326),
                'moderate', 'medium'
            )
            RETURNING global_id;
            """
            
            for course in parsed_courses:
                try:
                    # Generate UUID
                    course['global_id'] = str(uuid.uuid4())

                    # Check for duplicates (simple check by name)
                    cursor.execute("SELECT global_id FROM golfclub WHERE club_name = %s", (course['club_name'],))
                    if cursor.fetchone():
                        logger.info(f"Skipping existing club: {course['club_name']}")
                        continue

                    cursor.execute(insert_query, course)
                    count += 1
                except Exception as e:
                    logger.error(f"Error inserting {course['club_name']}: {e}")
                    conn.rollback() # Rollback this one but continue?
                    continue
            
            conn.commit()
            logger.info(f"Successfully imported {count} new courses")
            return count

    finally:
        conn.close()

if __name__ == "__main__":
    # Test run (e.g., around Pebble Beach)
    # 36.5698° N, 121.9510° W
    import_courses_for_location(36.5698, -121.9510, 10)
